/*
 * Zero Notification Service
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package server

import (
	"net/http"
	"time"

	"github.com/commitdev/zero-notification-service/internal/config"
	"github.com/commitdev/zero-notification-service/internal/log"
	"go.uber.org/zap"
)

// HTTP Reponse Writer with a little wrapper to collect the status code
type loggingResponseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (lrw *loggingResponseWriter) WriteHeader(code int) {
	lrw.statusCode = code
	lrw.ResponseWriter.WriteHeader(code)
}

func Logger(inner http.Handler, name string) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		lrw := &loggingResponseWriter{w, http.StatusOK}
		inner.ServeHTTP(lrw, r)

		// Use the global handler for 4xx status codes, as there won't be a route-specific one
		if !(lrw.statusCode >= 400 && lrw.statusCode <= 499) && name == "" {
			return
		}

		if config.GetConfig().StructuredLogging {
			// Don't log health checks in a cloud environment - name is defined in the schema
			if name != "ReadyCheck" {
				http := log.ECSHTTP{
					Request: log.ECSRequest{
						Method: r.Method,
					},
					Response: log.ECSResponse{
						StatusCode: lrw.statusCode,
					},
				}
				url := log.ECSURL{Original: r.RequestURI}
				event := log.ECSEvent{Action: name, Duration: time.Since(start)}
				trace := log.ECSTrace{ID: r.Header.Get("X-Request-ID")}

				zap.S().Infow("HTTP Request", zap.Any("http", http), zap.Any("url", url), zap.Any("event", event), zap.Any("trace", trace))
			}
		} else {
			zap.S().Infow("HTTP Request",
				"method", r.Method,
				"status_code", lrw.statusCode,
				"url", r.RequestURI,
				"action", name,
				"duration", time.Since(start),
				"request_id", r.Header.Get("X-Request-ID"),
			)
		}
	})
}
